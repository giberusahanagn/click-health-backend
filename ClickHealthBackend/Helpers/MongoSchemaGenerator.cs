using MongoDB.Bson;
using System;
using System.Collections;
using System.Linq;
using System.Reflection;

public static class MongoSchemaGenerator
{
    public static BsonDocument GenerateSchema<T>()
    {
        var type = typeof(T);
        var properties = type.GetProperties();
        var required = new BsonArray();
        var propsDoc = new BsonDocument();

        foreach (var prop in properties)
        {
            // Skip Id if you want optional (can be generated by MongoDB)
            var propNameAttr = prop.GetCustomAttributes(true)
                                   .OfType<MongoDB.Bson.Serialization.Attributes.BsonElementAttribute>()
                                   .FirstOrDefault();
            var propName = propNameAttr != null ? propNameAttr.ElementName : prop.Name;

            if (!IsNullable(prop))
                required.Add(propName);

            string bsonType = GetBsonType(prop.PropertyType);
            BsonDocument propDoc;

            if (IsClass(prop.PropertyType) && prop.PropertyType != typeof(string))
            {
                // Nested object
                propDoc = GenerateSchemaFromType(prop.PropertyType);
            }
            else
            {
                propDoc = new BsonDocument("bsonType", bsonType);
            }

            propsDoc.Add(propName, propDoc);
        }

        return new BsonDocument
        {
            { "bsonType", "object" },
            { "required", required },
            { "properties", propsDoc }
        };
    }

    private static bool IsNullable(PropertyInfo prop)
    {
        return Nullable.GetUnderlyingType(prop.PropertyType) != null || !prop.PropertyType.IsValueType;
    }

    private static bool IsClass(Type t)
    {
        return t.IsClass && t != typeof(string);
    }

    private static BsonDocument GenerateSchemaFromType(Type t)
    {
        var props = t.GetProperties();
        var required = new BsonArray();
        var propsDoc = new BsonDocument();

        foreach (var p in props)
        {
            var nameAttr = p.GetCustomAttributes(true)
                            .OfType<MongoDB.Bson.Serialization.Attributes.BsonElementAttribute>()
                            .FirstOrDefault();
            var propName = nameAttr != null ? nameAttr.ElementName : p.Name;

            if (!IsNullable(p))
                required.Add(propName);

            string bsonType = GetBsonType(p.PropertyType);
            propsDoc.Add(propName, new BsonDocument("bsonType", bsonType));
        }

        return new BsonDocument
        {
            { "bsonType", "object" },
            { "required", required },
            { "properties", propsDoc }
        };
    }

    private static string GetBsonType(Type t)
    {
        if (t == typeof(string)) return "string";
        if (t == typeof(int) || t == typeof(int?)) return "int";
        if (t == typeof(long) || t == typeof(long?)) return "long";
        if (t == typeof(bool) || t == typeof(bool?)) return "bool";
        if (t == typeof(DateTime) || t == typeof(DateTime?)) return "date";
        if (typeof(IEnumerable).IsAssignableFrom(t) && t != typeof(string)) return "array";
        if (t == typeof(MongoDB.Bson.BsonDocument)) return "object";
        return "string";
    }
}
